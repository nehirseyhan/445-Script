# Cargo Tracking System – Presentation Notes

This document is meant to be spoken through in a grading session. It focuses on *logic and behavior*, not Python syntax, and reflects the current implementations of `cargo_item.py`, `container.py`, `tracker.py` and `server.py`.

---

## 1. Big Picture: What the System Does

- We model a small cargo company.
- **Cargo items** represent individual packages.
- **Containers** represent physical locations or vehicles where items sit or move (front office, hub, truck, etc.).
- **Trackers / watchers** represent interested parties that want to be notified when something changes.
- A **TCP server** holds the shared state and exposes a text protocol.
- Multiple **clients** connect to the server to create items/containers, move items, watch for updates, and query status.
- `demo_watch.py` simulates realistic multi‑client scenarios (race conditions, watchers, persistence, disconnects, push vs polling).

When we present, we can keep repeating this mental model: *items inside containers, watched by trackers, updated through a TCP server*.

---

## 2. Domain Model: `CargoItem` and `CargoDirectory`

Files: `cargo_item.py`

### 2.1 Responsibilities
- Represents a single package’s business state.
- Owns:
  - Sender / recipient names and address.
  - Owner (who is responsible / customer).
  - Autogenerated tracking ID like `CI00000001`.
  - Current **state** (`accepted`, `waiting`, `in transit`, `complete`, `deleted`).
  - Which container it is currently in (if any).
  - Which trackers (observer objects) are subscribed to this item.

### 2.2 Lifecycle and invariants
- Constructor enforces that all four textual fields (sender, recipient, address, owner) are non‑empty.
- When created:
  - It generates a unique ID using a global counter (`CI` + zero‑padded integer).
  - Initial state is `accepted` (package has been accepted into the system but is not yet moving).
  - It has no container, no trackers, and `_deleted` is `False`.

### 2.3 Public behavior
- **`get()`**
  - Serializes all important fields into a JSON string.
  - Includes id, sender/recipient/owner, state, current container id, and deleted flag.
  - This is how the server sends item info back to clients.

// **`update(**updates)`**
- Generic update method used to change logical fields (sender, recipient, address, owner, state).
- It uses `_allowed_update_fields` to map incoming field names (like `sendernam`, `recipnam`) to internal attribute names.
- It rejects unknown fields and empty values so protocol mistakes fail fast.
- If at least one field actually changes, it calls `updated()` to notify trackers.

- **`delete()`**
  - Marks the item as deleted, sets its state to `deleted`, and clears its container.
  - Notifies trackers via `updated()` and clears the tracker set.

- **Container relation**
  - `getContainer()` returns the **container id** (not the object).
  - `setContainer(container)` is called from `Container.load/unload/move`:
    - Updates `_container` to the actual container object (or `None`).
    - Updates `_container_id` to the container’s `cid` (or `None`).
    - Adjusts the item’s state based on the container’s state:
      - If container is `None` and item is not yet `complete`, state goes back to `accepted`.
      - If container has `getState()`, use that string as the item’s state.
    - After changing, calls `updated()` so all trackers learn the new status.

- **Tracking / notification**
  - `_trackers` is a set of arbitrary watcher objects that must have an `updated()` method.
  - `track(tracker)` adds a new watcher (must be hashable, non‑`None`).
  - `untrack(tracker)` removes.
  - `updated()` iterates over all trackers and calls `tracker.updated(self)`; if a tracker expects no argument, it falls back to `tracker.updated()`.
  - `complete()` sets state to `complete` and calls `updated()`.

### 2.4 `CargoDirectory` – item registry

`CargoDirectory` is an in‑memory catalog of all items used by the server.

- Internally holds:
  - `_items`: `id -> CargoItem`.
  - `_attachments`: `id -> set(users)` for which users are “attached” to which items.

- Core operations:
  - `create(**kwargs)`
    - Constructs a new `CargoItem` and stores it under its tracking id.
    - Returns the generated id to the caller (e.g. the server session).

  - `list()`
    - Returns a list of `(id, json_string)` pairs for all existing items.

  - `listattached(user)`
    - Filters `_attachments` for a given user and returns their items.

  - `get(item_id)`
    - Returns the `CargoItem` object or raises if it does not exist.

  - `attach(item_id, user)` / `detach(item_id, user)`
    - Manage which human users are “attached” to a given item, following some constraints (non‑empty user; cannot detach a non‑attached user).

  - `delete(item_id)`
    - Only allowed if there are no attached users.
    - Calls `item.delete()` and then removes the item from the directory.

`CargoDirectory` is the core container for items that the **server** manipulates.

---

## 3. Domain Model: `Container`

File: `container.py`

### 3.1 Responsibilities
- Represents a physical container or location that can hold many `CargoItem`s.
- Knows:
  - `cid` (container id).
  - Textual `description`.
  - `type` – determines behavior (`FrontOffice`, `Hub`, `Truck`, etc.).
  - `loc` – a `(longitude, latitude)` pair.
  - The set of items currently inside (`_items`).
  - The set of trackers watching the container (`_trackers`).

### 3.2 Types and state mapping
- A constant `STATIONARY_TYPES = {"FrontOffice", "Hub"}`.
- `getState()` is used by items to interpret their own state:
  - If the container is stationary (front office or hub) → item state becomes `waiting`.
  - Otherwise (e.g., trucks) → item state becomes `in transit`.

### 3.3 Public behavior
- Constructor enforces:
  - Non‑empty id, description, type.
  - Valid location tuple with 2 numbers.

- **`get()`**
  - Returns a JSON string describing the container: id, type, location, list of item ids it holds, and deleted flag.

- **`update(**updates)`**
  - Generic update for mutable fields (description, type).
  - Similar pattern to `CargoItem.update()`.
  - If something changes, calls `updated()`.

- **`delete()`**
  - Marks the container as deleted.
  - Unloads *all* items (each item’s container is set to `None`, which updates their state and notifies their trackers).
  - Notifies any container trackers and then clears the tracker set.

- **Location and movement**
  - `setlocation(long, latt)` sets a new `(lon, lat)` for the container.
    - If location actually changes, calls `updated()`.
    - That causes downstream notifications:
      - Trackers watching the container get an `updated(self)` call.
      - Every item inside the container is updated (`item.updated()`), which pushes updates to item‑trackers.

  - `load(itemlist)`
    - Adds given items to this container’s set (if not already present).
    - For each item, calls `item.setContainer(self)`, which:
      - Assigns container id to the item.
      - Aligns item’s state with container’s `getState()`.
      - Notifies all of the item’s trackers.

  - `unload(itemlist)`
    - Removes items from this container’s set.
    - For each item, calls `item.setContainer(None)`, which normally resets item state back to `accepted` (unless already `complete`).

  - `move(itemlist, newcontainer)`
    - Helper that removes items from *this* container and adds them to `newcontainer`.
    - Again, uses `item.setContainer(newcontainer)` so all notification logic is reused.

- **Tracking / notification**
  - `track(tracker)` / `untrack(tracker)` manage watchers that want to hear about container changes.
  - `updated()`:
    - First, notifies all trackers:
      - Calls `tracker.updated(self)` if possible, else falls back to `tracker.updated()`.
    - Then, for each item inside, calls `item.updated()`, so item‑level trackers also see container changes indirectly.

---

## 4. Domain Model: `Tracker`

File: `tracker.py`

### 4.1 Responsibilities
- A `Tracker` object is a *logical observer* that watches multiple items and containers.
- This is different from network sessions: `Tracker` is an **in‑process** watcher used in phase 1.
- In phase 2, the same pattern is reused by a session‑level `Tracker` instance on the server side.

### 4.2 Internal state
- Identity: `tid`, `description`, `owner`.
- Sets of what it tracks:
  - `_items` – set of `CargoItem` objects.
  - `_containers` – set of `Container` objects.
- Optional geographical filter `_view_rect = (top, left, bottom, right)`.
- `_deleted` flag.

### 4.3 Attaching / detaching
- `addItem(itemlist)`
  - For each item, adds to `_items` and calls `item.track(self)`.

- `addContainer(contlist)`
  - For each container, adds to `_containers` and calls `cont.track(self)`.

- `delete()`
  - Marks tracker as deleted and then untracks itself from all items and containers.

### 4.4 Notifications: `updated(updated_object)`
- This method is called by items and containers when they change.
- For the homework’s phase‑1 usage, it prints to the terminal:
  - It identifies the updated object’s id (item tracking id or container id).
  - If a view rectangle is set, and the object has a location (container or item‑in‑container), it checks whether the location falls inside the rectangle.
  - If outside, it prints that the update is ignored.
  - Otherwise, prints a message like: “Tracker T1: Received update from CI00000002”.
 - In phase‑2 (the server), `Tracker` instances are typically constructed with an `on_update` callback; in that case `updated()` also forwards the event to the callback so the server can enqueue a network event for the session (the code calls the callback after printing).

### 4.5 Reports: `getStatlist()`
- Returns a list of summary dicts for currently tracked items.
- Each entry includes:
  - Item tracking id.
  - Item state.
  - Location (if the item is in a container with a location).
  - Id of the container.
- If a view rectangle is set, it filters items whose location is outside the view.

### 4.6 View rectangle: `setView(top, left, bottom, right)`
- Sets a rectangle in lon/lat space.
- Later, both `updated()` and `getStatlist()` use this to decide which updates/items are relevant.

---

## 5. Networking Layer: `server.py`

The server makes the domain model multi‑user and persistent.

### 5.1 Shared state and locking
- Global objects:
  - `_directory` – a `CargoDirectory` instance (all cargo items).
  - `_containers` – a dict `cid -> Container` (all containers).
  - `_model_lock` – a re‑entrant lock around all shared state.
- Every command that reads or writes the shared model wraps operations in `with _model_lock:` to protect against race conditions between threads.

### 5.2 How the server talks to the model

- `_directory` comes from `cargo_item.py` and stores all `CargoItem` objects.
- `_containers` maps container ids to `Container` instances from `container.py`.
- Almost all work in commands is limited to **looking up objects** in these two structures and then calling their methods.

Command → model operation mapping (high level):

- `CREATE_ITEM <s> <r> <addr> <owner>`
  - Calls `_directory.create(...)`, which builds and registers a new `CargoItem`.
  - Returns the generated tracking id (e.g. `CI00000001`).

- `CREATE_CONTAINER <cid> <desc> <type> <lon> <lat>`
  - Instantiates a `Container` object and stores it in `_containers[cid]`.

- `LIST_ITEMS`
  - Calls `_directory.list()` and returns the JSON snapshots produced by `CargoItem.get()`.

- `LIST_CONTAINERS`
  - Calls `cont.get()` for each container and returns the JSON list.

- `WATCH <item_id>`
  - Looks up the `CargoItem` and calls `item.track(session.tracker)`.
  - From now on, any call to `item.updated()` will enqueue an event in this session.

- `WATCH_CONTAINER <cid>`
  - Looks up the `Container` and calls `cont.track(session.tracker)`.

- `LOAD <item_id> <cid>`
  - Looks up the item and container.
  - Calls `cont.load([item])`.
  - Internally, `load()` calls `item.setContainer(cont)`, which updates the item’s container, state, and triggers `item.updated()`.

- `UNLOAD <item_id>`
  - Finds the item and its current container.
  - Calls `cont.unload([item])`, which sets the item’s container to `None` and calls `item.updated()`.

- `SETLOC <cid> <lon> <lat>`
  - Calls `cont.setlocation(lon, lat)`.
  - `setlocation()` calls `cont.updated()`, which notifies container watchers and in turn calls `item.updated()` for each contained item.

- `COMPLETE <item_id>`
  - Calls `item.complete()`, which changes the state to `complete` and calls `item.updated()`.

- `STATUS <item_id>`
  - Simply returns the JSON string from `item.get()`.

### 5.3 Persistence: `save_state()` and `load_state()`
- `save_state()`
  - Acquires the lock, serializes all items and containers to Python dicts, then writes them to `server_state.json`.
  - For items, it relies on `CargoItem.get()`’s JSON and parses it back into dicts.
  - For containers, it uses `Container.get()` and likewise.

- `load_state()`
  - If `server_state.json` exists, loads the JSON and reconstructs `CargoItem` and `Container` objects.
  - It rebuilds:
    - All containers (with ids, descriptions, types, locations).
    - All items (with fields, states, deleted flags).
    - Then uses the saved container id on each item to restore the relations: puts items into their containers and sets `_container` / `_container_id`.
  - Resets the `CargoItem._id_sequence` so that new ids continue from the maximum saved id.

### 5.4 Session model

Each TCP client connection is managed by a `Session` thread.

- **`Session` internal state**
  - `socket` – the TCP connection.
  - `username` – name set by the `USER` command.
  - `tracked_items` / `tracked_containers` – which domain objects this network session is watching.
  - `_buffer` – accumulation of incoming bytes until a newline.
  - An associated `Tracker` instance (`self.tracker`) for event notifications.
  - `cond`, `events`, `pending_events`, `_event_counter` – used to coordinate between the command handler and the asynchronous notification agent.

- **Receiving commands** (`run()` method)
  - Loop:
    - Receives raw bytes from the socket.
    - Accumulates into `_buffer` until it sees `\n`.
    - Extracts a single command line, strips, and passes to `handle(line)`.
  - `handle(line)` returns `(response_string, continue_flag)`.
    - `response_string` is sent back with a newline.
    - If `continue_flag` is `False`, it stops the session.
  - If any exception occurs in `handle`, it sends back an `ERR ...` message instead of crashing.

### 5.5 Text protocol (commands)

Each command is a single line of space‑separated tokens, interpreted by `Session.handle()`.

We can present it as a mini‑API:

- **`HELP`** → Lists all supported commands.

- **`USER <name>`** → Sets `session.username`, used mostly for friendliness.

- **Item and container creation**
  - `CREATE_ITEM <sender> <recipient> <address> <owner>`
    - Calls `_directory.create(...)` under the model lock.
    - Returns `OK <item_id>`.

  - `CREATE_CONTAINER <cid> <desc> <type> <lon> <lat>`
    - Creates a new `Container` with given id, description, type, and location.
    - Fails if the id is already used.

- **Listing**
  - `LIST_ITEMS`
    - Returns all items as JSON array: `OK [ {...}, {...} ]`.

  - `LIST_CONTAINERS`
    - Returns all containers similarly.

- **Watching (event subscription)**
  - `WATCH <item_id>`
    - Locates the `CargoItem` in `_directory._items`.
    - Calls `item.track(self.watcher)`; adds it to `session.tracked_items`.
    - From this point on, any `item.updated()` triggers an event to this session.

  - `WATCH_CONTAINER <cid>`
    - Locates the container in `_containers`.
    - Calls `cont.track(self.watcher)` and tracks it in `session.tracked_containers`.

- **Operations on items and containers**
  - `LOAD <item_id> <cid>`
    - Checks that both item and container exist.
    - If item is already in another container, raises an error.
    - Calls `cont.load([item])`, which updates both the container and the item’s state and triggers notifications.

  - `UNLOAD <item_id>`
    - Ensures the item exists and is currently in a container.
    - Calls `cont.unload([item])`, which removes the link to the container and typically moves the item state back to `accepted`.

  - `COMPLETE <item_id>`
    - Calls `item.complete()` to mark it as delivered.

  - `SETLOC <cid> <lon> <lat>`
    - Finds the container and calls `setlocation()`.
    - This triggers container and item notifications as described above.

  - `STATUS <item_id>`
    - Sends back the item’s current JSON via `item.get()`.

- **Events, save, and session lifecycle**

  - `WAIT_EVENTS`
    - This is **synchronous** event waiting.
    - Internally, it:
      - Records the current `_event_counter`.
      - Waits on the session’s condition variable until `_event_counter` changes or a timeout is reached.
      - If any new events have been queued, it returns `OK event available`; otherwise `OK no pending events`.

  - `SAVE`
    - Calls `save_state()` to write the current model to disk.

  - `QUIT`
    - Returns `OK bye` and signals that this session should stop.

### 5.6 Event pipeline: session `Tracker` and `notificationagent`

- **Session `Tracker`**
  - The server constructs a `Tracker` instance per session and passes it into items and containers as their watcher.
  - The tracker's `updated(updated_object)` method:
    - Builds a concise event dict: timestamp + a tuple describing the object.
      - For cargo items: `( "cargo", trackingId, state )`.
      - For containers: `( "container", cid, loc )`.
    - Appends this dict into `session.events` and increments `pending_events` and `_event_counter` under the session’s condition.
    - Notifies the condition so that the notification agent (and `WAIT_EVENTS`) wake up.

- **`notificationagent(session)` thread**
  - Each session starts a background thread that continuously watches `session.events`.
  - When an event is available:
    - Pops the oldest event.
    - Sends it to the client as a line: `EVENT {json}`.
    - Decrements `pending_events` and notifies the condition.
  - When the session stops and the queue is empty, the thread exits.

- **`Session.close()`**
  - Before tearing down the socket, it unregisters its watcher from all items and containers it was tracking.
  - This ensures no domain object ever tries to notify a dead session.

### 5.7 Server main loop

- At start: parses optional port, calls `load_state()` to restore previous data.
- Binds a TCP socket and listens.
- For each incoming connection:
  - Accepts the socket, wraps it in a new `Session` object, starts the thread.
- On server shutdown:
  - Closes the listening socket and calls `save_state()` one last time.

---

## 6. Demo client: `demo_watch.py`

Use `demo_watch.py` as the canonical way to exercise the system for demos and tests.

- `demo_watch.py` spawns the server and multiple scripted `DemoClient` threads to exercise commands, watchers, and failure modes.
- It captures and colorizes client output so you can clearly follow which client performed which action and which notifications each received.

This approach provides repeatable, visible demonstrations of concurrency, notifications, persistence, and error handling.
---

## 7. Automated Demo Scenarios: `demo_watch.py`

`demo_watch.py` acts like a scripted set of clients to demonstrate and stress‑test the system behavior. It contains several scenarios; each:
- Starts a fresh server instance.
- Spins up multiple `DemoClient` threads.
- Each `DemoClient` executes a scripted list of actions (commands + time delays).
- At the end, the server is stopped and optionally the state file is cleaned up.

### 7.1 `DemoClient` behavior

- On `start()`:
  - Connects to the server and sends a `USER <name>` command.
  - Starts a `listen` thread to continuously read responses from the server, line by line.
  - Walks through its configured actions:
    - If an action is a number → sleep that many seconds.
    - If an action is a string → send that line as a command to the server.
    - A special action `__CLOSE_SOCKET__` simulates an abrupt disconnect.

- The `listen` method:
  - Parses lines from the server:
    - Lines starting with `EVENT` are parsed as JSON and logged as notifications.
    - `OK [` is treated as a bulk data dump (lists).
    - `ERR` is logged as an error.

This gives us **repeatable, timed interactions** with multiple clients.

### 7.2 Scenario overview

When presenting, we don’t need to run all scenarios live; we can explain what each is testing logically:

1. **Scenario 1 – Concurrent Updates (Race Condition)**
   - Server is started.
   - One client creates a container `RACE_CONT`.
   - Two updater clients both try to set the location of the same container almost at the same time (50ms apart).
   - A watcher client is watching that container.
   - Demonstrates:
     - Why `_model_lock` is necessary: both `SETLOC` commands run safely.
     - Final location is whichever update happens last, but system remains consistent.
     - Watcher sees the sequence of `EVENT` notifications.

2. **Scenario 2 – Item Watchers (2 common, 1 exclusive)**
   - Creates three cargo items and one truck container `TRUCK1`.
   - Loads items 2 and 3 into `TRUCK1`, moves truck, unloads item 2, etc.
   - Two watchers both watch item 2; one watcher exclusively watches item 3.
   - Demonstrates:
     - Multiple watchers on the same item all get the same updates.
     - Load/unload and location changes of the container propagate to item watchers.

3. **Scenario 3 – Container Watchers (2 common, 1 exclusive)**
   - Creates items and two containers: `CONT_COM` (common) and `CONT_EXC` (exclusive).
   - Some watchers watch `CONT_COM`, others `CONT_EXC`.
   - Moves both containers.
   - Demonstrates:
     - Container watchers get events only for the containers they are tracking.

4. **Scenario 4 – Mixed Watching (1 cargo, 1 container)**
   - One client watches both an item and a container.
   - Another client completes the item and moves the container.
   - Demonstrates:
     - A single session can subscribe to many objects and will see both item and container events.

5. **Scenario 5 – Save & Persistence**
   - First run: creates an item and calls `SAVE`, then server is stopped without deleting `server_state.json`.
   - Second run: restarts the server, calls `LIST_ITEMS`, then stops.
   - Demonstrates:
     - `save_state()` and `load_state()` persist the whole model across restarts.

6. **Scenario 6 – Synchronous Waiting (`WAIT_EVENTS`)**
   - One client creates an item.
   - Another client watches that item and then sends `WAIT_EVENTS`.
   - A third client completes the item later.
   - Demonstrates:
     - `WAIT_EVENTS` blocks until an event occurs or timeout.
     - When the third client’s update triggers an event, the waiting client’s command unblocks with `OK event available`.

7. **Scenario 7 – Polling vs. Pushing**
   - One client is a watcher that passively waits for notifications.
   - Another client is a poller that repeatedly sends `STATUS` requests.
   - A third client completes the item in the middle.
   - Demonstrates two patterns:
     - Push model: watcher gets an `EVENT` as soon as state changes.
     - Pull model: poller sees state change only when it asks again.

8. **Scenario 8 – Client Disconnection Handling**
   - One client watches an item, then abruptly closes its socket (simulating a crash or network failure).
   - Another client continues to complete items.
   - Demonstrates:
    - Server’s `Session` and per‑session `Tracker` logic tolerate disappearing clients.
     - `close()` unregisters watchers and the system continues functioning.

---

## 8. How to Present in Grading

### 8.1 Suggested flow

1. **Start with the conceptual diagram**:
   - Boxes for `CargoItem`, `Container`, `Tracker`.
   - Arrows:
     - Item → Container ("is in").
     - Item/Container → Tracker ("notifies").
     - Clients → Server ("send commands / receive events").

2. **Walk through single‑item lifecycle**:
   - `CREATE_ITEM` → item in state `accepted`.
   - `CREATE_CONTAINER` & `LOAD` → item moves into container, state becomes `waiting` or `in transit` depending on type.
   - `SETLOC` changes container position → watchers for container and item see updates.
   - `UNLOAD` → item leaves container, state returns to `accepted`.
   - `COMPLETE` → final state `complete`.

3. **Explain the watcher / event mechanism** on top of that:
   - When item or container changes, they call their `updated()` methods.
  - For trackers (the in‑process `Tracker` or the session's tracker), `updated()` becomes a callback.
  - On the server, the session's `Tracker` callback packages these into `EVENT` messages.

4. **Point out concurrency and safety**:
   - Each client connection is a thread (`Session`).
   - All modifications to the shared model are under `_model_lock`.
   - `demo_watch.py` scenario 1 shows concurrent updates but consistent final state.

5. **Show persistence**:
  - Diagram how `save_state()` and `load_state()` serialize items and containers.
  - Mention that `demo_watch` scenario 5 demonstrates this.

6. **Finish with demo** (if time):
  - Run `server.py`.
  - Run `demo_watch.py` to replay scripted scenarios that highlight notifications, races, persistence, and disconnects.
  - Optionally run the test scenarios selectively for specific proofs.

### 8.2 What not to focus on

- Do **not** emphasize Python syntax or libraries; instead, emphasize:
  - Data flow: who calls whom.
  - State transitions of items and containers.
  - Event propagation and concurrency control.

---

## 9. Key Takeaways

- The core of the system is the **domain model** (items, containers, trackers) with clean responsibilities and clear state transitions.
- The **server** wraps this model in a concurrent, persistent, multi‑client TCP service.
-- The **demo script** is the main front‑end for reproducible tests and demonstrations:
  - Automated scenario tests (`demo_watch.py`).
- Across all components, the pattern is consistent:
  - Change state → call `updated()` → propagate to watchers → optionally persist.
